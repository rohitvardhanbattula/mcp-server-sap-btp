"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeDateToMoment = deserializeDateToMoment;
exports.serializeToDate = serializeToDate;
exports.deserializeDateTimeOffsetToMoment = deserializeDateTimeOffsetToMoment;
exports.serializeToDateTimeOffset = serializeToDateTimeOffset;
exports.deserializeDurationToMoment = deserializeDurationToMoment;
exports.serializeToDuration = serializeToDuration;
exports.deserializeToTime = deserializeToTime;
exports.serializeToTime = serializeToTime;
const internal_1 = require("@sap-cloud-sdk/odata-common/internal");
const moment_1 = __importDefault(require("moment"));
/**
 * @internal
 */
function deserializeDateToMoment(date) {
    const parsed = moment_1.default.utc(date, 'Y-MM-DD', true);
    if (!parsed.isValid()) {
        throw new Error(`Provided date value ${date} does not follow the Edm.Date pattern: YYYY-MM-DD`);
    }
    return parsed;
}
/**
 * @internal
 */
function serializeToDate(value) {
    return value.format('YYYY-MM-DD');
}
/**
 * @internal
 */
function deserializeDateTimeOffsetToMoment(dateTime) {
    const prefix = 'Y-MM-DDTHH:mm';
    // In moment the ZZ is either Offset from UTC as +-HH:mm, +-HHmm, or Z
    const validFormats = [`${prefix}ZZ`, `${prefix}:ssZZ`, `${prefix}:ss.SSSSZZ`];
    const parsed = (0, moment_1.default)(dateTime, validFormats, true);
    if (!parsed.isValid()) {
        throw new Error(`Provided date-time value ${dateTime} does not follow the Edm.DateTimeOffset pattern: YYYY-MM-DDTHH:mm(:ss(.SSSS))ZZ`);
    }
    return parsed;
}
/**
 * @internal
 */
function serializeToDateTimeOffset(value, precision) {
    // For temporal values, OData specification restricts precision values to a non-negative integer between 0 and 12
    if (precision !== undefined && !validatePrecision(precision)) {
        throw new Error(`Provided precision value: ${precision} is invalid. Precision must lie between 0 and 12`);
    }
    // If precision is defined, create a format with decimal places or default to 0 decimal places
    const dateTimeOffesetFormat = precision
        ? `YYYY-MM-DDTHH:mm:ss.${new Array(precision).fill('S').join('')}`
        : 'YYYY-MM-DDTHH:mm:ss';
    return value.utc().format(dateTimeOffesetFormat) + 'Z';
}
function validatePrecision(precision) {
    return precision >= 0 && precision <= 12;
}
/**
 * @internal
 */
function deserializeDurationToMoment(value) {
    const captured = internal_1.durationRegexV4.exec(value);
    if (!captured || captured[0] !== value) {
        throw new Error(`Provided duration value ${value} does not follow the Edm.Duration pattern: +/- P0DT0H0M0S`);
    }
    return moment_1.default.duration(value);
}
/**
 * @internal
 */
function serializeToDuration(value) {
    return value.toISOString();
}
/**
 * @internal
 */
function deserializeToTime(value) {
    // Matches a time with HH:mm:ss.SSSS like 15:05:06
    // See more: https://regex101.com/r/A5DHee/2
    const timeComponents = /^([01]\d|2[0-3]):([0-5][0-9]):([0-5][0-9](\.[0-9]+)?)$|^(24):(00):(00(\.0+)?)$/.exec(value);
    if (!timeComponents) {
        throw new Error(`Provided time value ${value} does not follow the Edm.TimeOfDay pattern: HH:MM:SS(.S)`);
    }
    return {
        hours: parseInt(timeComponents[1] || timeComponents[5]),
        minutes: parseInt(timeComponents[2] || timeComponents[6]),
        seconds: parseFloat(timeComponents[3] || timeComponents[7])
    };
}
/**
 * @internal
 */
function serializeToTime(value) {
    if (!validateTime(value)) {
        throw new Error(`Provided time value ${value} can not be serialized to a valid Edm.TimeOfDay`);
    }
    return [value.hours, value.minutes, value.seconds]
        .map(timeComponent => padTimeComponent(timeComponent))
        .join(':');
}
function validateTime({ hours, minutes, seconds }) {
    if (hours === 24 && minutes === 0 && seconds === 0) {
        return true;
    }
    if (hours < 0 || minutes < 0 || seconds < 0) {
        return false;
    }
    if (hours > 23 || minutes > 59 || seconds > 59) {
        return false;
    }
    return true;
}
function padTimeComponent(timeComponent) {
    const [wholeNumber, fractionalNumber] = timeComponent.toString().split('.');
    return fractionalNumber
        ? [wholeNumber.padStart(2, '0'), fractionalNumber].join('.')
        : wholeNumber.padStart(2, '0');
}
//# sourceMappingURL=converters.js.map